Directory Structure:

└── ./
    └── pkg
        ├── prompts
        │   ├── handler.go
        │   ├── manager.go
        │   └── prompt.go
        ├── resources
        │   ├── agent_manager.go
        │   ├── handler.go
        │   ├── manager.go
        │   ├── resource.go
        │   ├── subscription.go
        │   └── template.go
        ├── roots
        │   ├── handler.go
        │   ├── manager.go
        │   └── roots.go
        └── sampling
            ├── handler.go
            ├── manager.go
            └── sampling.go



---
File: /pkg/prompts/handler.go
---

package prompts

import (
	"context"

	"github.com/mark3labs/mcp-go/mcp"
)

// MCPHandler handles MCP requests for prompts
type MCPHandler struct {
	manager PromptManager
}

// NewMCPHandler creates a new MCPHandler
func NewMCPHandler(manager PromptManager) *MCPHandler {
	return &MCPHandler{
		manager: manager,
	}
}

// HandleListPrompts handles the prompts/list request
func (h *MCPHandler) HandleListPrompts(ctx context.Context, req *mcp.ListPromptsRequest) (*mcp.ListPromptsResult, error) {
	prompts, err := h.manager.List(ctx)
	if err != nil {
		return nil, err
	}

	// Convert prompts to MCP format
	mcpPrompts := make([]mcp.Prompt, len(prompts))
	for i, p := range prompts {
		mcpPrompts[i] = mcp.NewPrompt(p.Name,
			mcp.WithPromptDescription(p.Description),
		)
	}

	return mcp.NewListPromptsResult(mcpPrompts, ""), nil
}

// HandleGetPrompt handles the prompts/get request
func (h *MCPHandler) HandleGetPrompt(ctx context.Context, req *mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
	// Get all prompts and find the one with matching name
	prompts, err := h.manager.List(ctx)
	if err != nil {
		return nil, err
	}

	var prompt *Prompt
	for _, p := range prompts {
		if p.Name == req.Params.Name {
			prompt = &p
			break
		}
	}

	if prompt == nil {
		return nil, ErrorPromptNotFound{ID: req.Params.Name}
	}

	// Convert prompt content to MCP format
	messages := []mcp.PromptMessage{
		mcp.NewPromptMessage(mcp.RoleUser, mcp.NewTextContent(prompt.Content)),
	}

	// If it's a multi-step prompt, get the steps
	if prompt.Type == MultiStepPrompt {
		steps, err := h.manager.GetSteps(ctx, prompt.ID)
		if err != nil {
			return nil, err
		}

		// Add each step as a message
		for _, step := range steps {
			messages = append(messages, mcp.NewPromptMessage(
				mcp.RoleUser,
				mcp.NewTextContent(step.Content),
			))
		}
	}

	return mcp.NewGetPromptResult(prompt.Description, messages), nil
}

// HandleGetPromptSteps handles the prompts/getSteps request
func (h *MCPHandler) HandleGetPromptSteps(ctx context.Context, req *mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
	// Get all prompts and find the one with matching name
	prompts, err := h.manager.List(ctx)
	if err != nil {
		return nil, err
	}

	var prompt *Prompt
	for _, p := range prompts {
		if p.Name == req.Params.Name {
			prompt = &p
			break
		}
	}

	if prompt == nil {
		return nil, ErrorPromptNotFound{ID: req.Params.Name}
	}

	if prompt.Type != MultiStepPrompt {
		return nil, ErrorInvalidPromptType{ID: prompt.ID, Type: prompt.Type}
	}

	steps, err := h.manager.GetSteps(ctx, prompt.ID)
	if err != nil {
		return nil, err
	}

	// Convert steps to messages
	messages := make([]mcp.PromptMessage, len(steps))
	for i, step := range steps {
		messages[i] = mcp.NewPromptMessage(
			mcp.RoleUser,
			mcp.NewTextContent(step.Content),
		)
	}

	return mcp.NewGetPromptResult(prompt.Description, messages), nil
}



---
File: /pkg/prompts/manager.go
---

package prompts

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
)

type ErrorPromptNotFound struct {
	ID string
}

func (err ErrorPromptNotFound) Error() string {
	return fmt.Sprintf("prompt not found: %s", err.ID)
}

type ErrorStepNotFound struct {
	ID string
}

func (err ErrorStepNotFound) Error() string {
	return fmt.Sprintf("step not found: %s", err.ID)
}

type ErrorNoStepsForPrompt struct {
	ID string
}

func (err ErrorNoStepsForPrompt) Error() string {
	return fmt.Sprintf("no steps found for prompt: %s", err.ID)
}

type ErrorInvalidPromptType struct {
	ID   string
	Type PromptType
}

func (err ErrorInvalidPromptType) Error() string {
	return fmt.Sprintf("invalid prompt type for prompt %s: %s", err.ID, err.Type)
}

type ErrorDuplicateStepOrder struct {
	PromptID string
	Order    int
}

func (err ErrorDuplicateStepOrder) Error() string {
	return fmt.Sprintf("duplicate step order %d found in prompt %s", err.Order, err.PromptID)
}

type ErrorInvalidStepOrder struct {
	PromptID string
	Order    int
}

func (err ErrorInvalidStepOrder) Error() string {
	return fmt.Sprintf("invalid step order %d in prompt %s", err.Order, err.PromptID)
}

// DefaultManager is a basic implementation of PromptManager
type DefaultManager struct {
	prompts map[string]*Prompt
	steps   map[string][]*PromptStep
	mu      sync.RWMutex
}

// NewDefaultManager creates a new DefaultManager instance
func NewDefaultManager() *DefaultManager {
	m := &DefaultManager{
		prompts: make(map[string]*Prompt),
		steps:   make(map[string][]*PromptStep),
	}

	// Add some test prompts
	m.addTestPrompts()

	return m
}

// addTestPrompts adds some test prompts to the manager
func (m *DefaultManager) addTestPrompts() {
	// Add a single-step prompt
	singlePrompt := &Prompt{
		ID:          uuid.New().String(),
		Name:        "Simple Greeting",
		Description: "A simple greeting prompt",
		Type:        SingleStepPrompt,
		Content:     "Hello, how can I help you today?",
		Version:     "1.0.0",
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}
	m.prompts[singlePrompt.ID] = singlePrompt

	// Add a multi-step prompt
	multiPrompt := &Prompt{
		ID:          uuid.New().String(),
		Name:        "Customer Support",
		Description: "A multi-step customer support prompt",
		Type:        MultiStepPrompt,
		Content:     "This is a multi-step customer support prompt",
		Version:     "1.0.0",
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}
	m.prompts[multiPrompt.ID] = multiPrompt

	// Add steps for the multi-step prompt
	step1 := &PromptStep{
		ID:          uuid.New().String(),
		PromptID:    multiPrompt.ID,
		Name:        "Initial Greeting",
		Description: "Initial greeting to the customer",
		Content:     "Hello, thank you for contacting our support team. How can I assist you today?",
		Order:       1,
	}
	step2 := &PromptStep{
		ID:          uuid.New().String(),
		PromptID:    multiPrompt.ID,
		Name:        "Gather Information",
		Description: "Gather information about the customer's issue",
		Content:     "Could you please provide more details about your issue?",
		Order:       2,
	}
	step3 := &PromptStep{
		ID:          uuid.New().String(),
		PromptID:    multiPrompt.ID,
		Name:        "Provide Solution",
		Description: "Provide a solution to the customer's issue",
		Content:     "Based on your description, here's what I recommend:",
		Order:       3,
	}
	step4 := &PromptStep{
		ID:          uuid.New().String(),
		PromptID:    multiPrompt.ID,
		Name:        "Closing",
		Description: "Close the conversation",
		Content:     "Is there anything else I can help you with?",
		Order:       4,
	}

	m.steps[multiPrompt.ID] = []*PromptStep{step1, step2, step3, step4}
}

// List returns all available prompts
func (m *DefaultManager) List(ctx context.Context) ([]Prompt, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	prompts := make([]Prompt, 0, len(m.prompts))
	for _, p := range m.prompts {
		prompts = append(prompts, *p)
	}

	return prompts, nil
}

// Get retrieves a prompt by ID
func (m *DefaultManager) Get(ctx context.Context, id string) (*Prompt, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	prompt, ok := m.prompts[id]
	if !ok {
		return nil, ErrorPromptNotFound{ID: id}
	}

	return prompt, nil
}

// GetSteps retrieves all steps for a multi-step prompt
func (m *DefaultManager) GetSteps(ctx context.Context, promptID string) ([]PromptStep, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	// Check if the prompt exists
	prompt, ok := m.prompts[promptID]
	if !ok {
		return nil, ErrorPromptNotFound{ID: promptID}
	}

	// Check if the prompt is a multi-step prompt
	if prompt.Type != MultiStepPrompt {
		return nil, ErrorInvalidPromptType{ID: promptID, Type: prompt.Type}
	}

	// Get the steps
	steps, ok := m.steps[promptID]
	if !ok {
		return nil, ErrorNoStepsForPrompt{ID: promptID}
	}

	// Convert to slice of PromptStep
	result := make([]PromptStep, len(steps))
	for i, step := range steps {
		result[i] = *step
	}

	return result, nil
}

// Create creates a new prompt
func (m *DefaultManager) Create(ctx context.Context, prompt Prompt) (*Prompt, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Generate a new ID if not provided
	if prompt.ID == "" {
		prompt.ID = uuid.New().String()
	}

	// Set timestamps
	now := time.Now()
	prompt.CreatedAt = now
	prompt.UpdatedAt = now

	// Store the prompt
	m.prompts[prompt.ID] = &prompt

	// Initialize steps for multi-step prompts
	if prompt.Type == MultiStepPrompt {
		m.steps[prompt.ID] = make([]*PromptStep, 0)
	}

	return &prompt, nil
}

// Update updates an existing prompt
func (m *DefaultManager) Update(ctx context.Context, prompt Prompt) (*Prompt, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Check if the prompt exists
	existingPrompt, ok := m.prompts[prompt.ID]

	if !ok {
		return nil, ErrorPromptNotFound{ID: prompt.ID}
	}

	// Update the prompt
	prompt.CreatedAt = existingPrompt.CreatedAt
	prompt.UpdatedAt = time.Now()
	m.prompts[prompt.ID] = &prompt

	return &prompt, nil
}

// Delete deletes a prompt
func (m *DefaultManager) Delete(ctx context.Context, id string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Check if the prompt exists
	_, ok := m.prompts[id]
	if !ok {
		return ErrorPromptNotFound{ID: id}
	}

	// Delete the prompt
	delete(m.prompts, id)

	// Delete the steps if it's a multi-step prompt
	delete(m.steps, id)

	return nil
}

// CreateStep creates a new step for a multi-step prompt
func (m *DefaultManager) CreateStep(ctx context.Context, step PromptStep) (*PromptStep, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Check if the prompt exists
	prompt, ok := m.prompts[step.PromptID]
	if !ok {
		return nil, ErrorPromptNotFound{ID: step.PromptID}
	}

	// Check if the prompt is a multi-step prompt
	if prompt.Type != MultiStepPrompt {
		return nil, ErrorInvalidPromptType{ID: step.PromptID, Type: prompt.Type}
	}

	// Generate a new ID if not provided
	if step.ID == "" {
		step.ID = uuid.New().String()
	}

	// Get the existing steps
	steps, ok := m.steps[step.PromptID]
	if !ok {
		steps = make([]*PromptStep, 0)
	}

	// Validate step order
	if step.Order <= 0 {
		return nil, ErrorInvalidStepOrder{PromptID: step.PromptID, Order: step.Order}
	}

	// Check for duplicate order
	for _, s := range steps {
		if s.Order == step.Order {
			return nil, ErrorDuplicateStepOrder{PromptID: step.PromptID, Order: step.Order}
		}
	}

	// Add the new step
	steps = append(steps, &step)
	m.steps[step.PromptID] = steps

	return &step, nil
}

// UpdateStep updates an existing step
func (m *DefaultManager) UpdateStep(ctx context.Context, step PromptStep) (*PromptStep, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Check if the prompt exists
	_, ok := m.prompts[step.PromptID]
	if !ok {
		return nil, ErrorPromptNotFound{ID: step.PromptID}
	}

	// Get the existing steps
	steps, ok := m.steps[step.PromptID]
	if !ok {
		return nil, ErrorNoStepsForPrompt{ID: step.PromptID}
	}

	// Find and update the step
	found := false
	for i, s := range steps {
		if s.ID == step.ID {
			steps[i] = &step
			found = true
			break
		}
	}

	if !found {
		return nil, ErrorStepNotFound{ID: step.ID}
	}

	return &step, nil
}

// DeleteStep deletes a step
func (m *DefaultManager) DeleteStep(ctx context.Context, stepID string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Find the step
	var promptID string
	var stepIndex int
	found := false

	for pid, steps := range m.steps {
		for i, step := range steps {
			if step.ID == stepID {
				promptID = pid
				stepIndex = i
				found = true
				break
			}
		}
		if found {
			break
		}
	}

	if !found {
		return ErrorStepNotFound{ID: stepID}
	}

	// Remove the step
	steps := m.steps[promptID]
	m.steps[promptID] = append(steps[:stepIndex], steps[stepIndex+1:]...)

	return nil
}



---
File: /pkg/prompts/prompt.go
---

package prompts

import (
	"context"
	"time"
)

// PromptType represents the type of prompt
type PromptType string

const (
	// SingleStepPrompt is a simple one-step prompt
	SingleStepPrompt PromptType = "single"
	// MultiStepPrompt is a prompt that requires multiple steps
	MultiStepPrompt PromptType = "multi"
)

// Prompt represents a prompt that can be used for various purposes
type Prompt struct {
	ID          string     `json:"id"`
	Name        string     `json:"name"`
	Description string     `json:"description"`
	Type        PromptType `json:"type"`
	Content     string     `json:"content"`
	Version     string     `json:"version"`
	CreatedAt   time.Time  `json:"createdAt"`
	UpdatedAt   time.Time  `json:"updatedAt"`
	Metadata    any        `json:"metadata,omitempty"`
}

// PromptStep represents a step in a multi-step prompt
type PromptStep struct {
	ID          string `json:"id"`
	PromptID    string `json:"promptId"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Content     string `json:"content"`
	Order       int    `json:"order"`
	Metadata    any    `json:"metadata,omitempty"`
}

// PromptManager defines the interface for managing prompts
type PromptManager interface {
	// List returns all available prompts
	List(ctx context.Context) ([]Prompt, error)

	// Get retrieves a prompt by ID
	Get(ctx context.Context, id string) (*Prompt, error)

	// GetSteps retrieves all steps for a multi-step prompt
	GetSteps(ctx context.Context, promptID string) ([]PromptStep, error)

	// Create creates a new prompt
	Create(ctx context.Context, prompt Prompt) (*Prompt, error)

	// Update updates an existing prompt
	Update(ctx context.Context, prompt Prompt) (*Prompt, error)

	// Delete deletes a prompt
	Delete(ctx context.Context, id string) error

	// CreateStep creates a new step for a multi-step prompt
	CreateStep(ctx context.Context, step PromptStep) (*PromptStep, error)

	// UpdateStep updates an existing step
	UpdateStep(ctx context.Context, step PromptStep) (*PromptStep, error)

	// DeleteStep deletes a step
	DeleteStep(ctx context.Context, stepID string) error
}



---
File: /pkg/resources/agent_manager.go
---

package resources

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"sync"

	"github.com/theapemachine/caramba/pkg/catalog"
	"github.com/theapemachine/caramba/pkg/errnie"
)

// AgentResourceManager implements ResourceManager to expose A2A agents as MCP resources
type AgentResourceManager struct {
	catalog       *catalog.Catalog
	subscriptions map[string][]*Subscription
	subManager    *SubscriptionManager
	mu            sync.RWMutex
}

// NewAgentResourceManager creates a new resource manager for A2A agents
func NewAgentResourceManager(catalog *catalog.Catalog) *AgentResourceManager {
	return &AgentResourceManager{
		catalog:       catalog,
		subscriptions: make(map[string][]*Subscription),
		subManager:    NewSubscriptionManager(),
	}
}

// List returns all available agent resources
func (m *AgentResourceManager) List(ctx context.Context) ([]Resource, []ResourceTemplate, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	var resources []Resource

	// Get all agents from the catalog
	agents := m.catalog.GetAgents()

	// Convert each agent card to a resource
	for _, agentCard := range agents {
		uri := fmt.Sprintf("agent://%s", agentCard.Name)

		// Create a resource for the agent
		resource := Resource{
			URI:         uri,
			Name:        agentCard.Name,
			Description: agentCard.Description,
			MimeType:    "application/json",
			Type:        TextResource,
		}

		resources = append(resources, resource)
	}

	// Add a template for dynamic agent access
	templates := []ResourceTemplate{
		{
			URITemplate: "agent://{name}",
			Name:        "A2A Agent",
			Description: "Access A2A agent resources by name",
			MimeType:    "application/json",
			Type:        TextResource,
			Variables: []TemplateVariable{
				{
					Name:        "name",
					Description: "The name of the agent",
					Required:    true,
				},
			},
		},
	}

	return resources, templates, nil
}

// Read reads the content of an agent resource
func (m *AgentResourceManager) Read(ctx context.Context, uri string) ([]ResourceContent, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	// Parse the URI to extract the agent name
	if !strings.HasPrefix(uri, "agent://") {
		return nil, fmt.Errorf("invalid agent URI format: %s", uri)
	}

	agentName := strings.TrimPrefix(uri, "agent://")
	if agentName == "" {
		return nil, fmt.Errorf("missing agent name in URI: %s", uri)
	}

	// Get the agent from the catalog
	agentCard := m.catalog.GetAgent(agentName)
	if agentCard == nil {
		return nil, fmt.Errorf("agent not found: %s", agentName)
	}

	// Convert the agent card to JSON
	cardJSON, err := json.MarshalIndent(agentCard, "", "  ")
	if err != nil {
		return nil, fmt.Errorf("failed to serialize agent card: %w", err)
	}

	// Create a resource content with the agent card JSON
	content := ResourceContent{
		URI:      uri,
		MimeType: "application/json",
		Text:     string(cardJSON),
	}

	return []ResourceContent{content}, nil
}

// Subscribe subscribes to agent resource updates
func (m *AgentResourceManager) Subscribe(ctx context.Context, uri string) error {
	// Parse the URI to extract the agent name
	if !strings.HasPrefix(uri, "agent://") {
		return fmt.Errorf("invalid agent URI format: %s", uri)
	}

	agentName := strings.TrimPrefix(uri, "agent://")
	if agentName == "" {
		return fmt.Errorf("missing agent name in URI: %s", uri)
	}

	// Create a new subscription
	_, err := m.subManager.Subscribe(ctx, uri)
	if err != nil {
		return fmt.Errorf("failed to create subscription: %w", err)
	}

	errnie.Debug(fmt.Sprintf("Subscribed to agent resource: %s", uri))

	return nil
}

// Unsubscribe unsubscribes from agent resource updates
func (m *AgentResourceManager) Unsubscribe(ctx context.Context, uri string) error {
	subs := m.subManager.GetSubscriptions(uri)
	for _, sub := range subs {
		m.subManager.Unsubscribe(uri, sub)
	}

	errnie.Debug(fmt.Sprintf("Unsubscribed from agent resource: %s", uri))

	return nil
}

// NotifyUpdate notifies subscribers of an agent update
func (m *AgentResourceManager) NotifyUpdate(agentName string) {
	// Create the URI for the agent
	uri := fmt.Sprintf("agent://%s", agentName)

	// Get the agent from the catalog
	agentCard := m.catalog.GetAgent(agentName)
	if agentCard == nil {
		errnie.New(errnie.WithMessage(fmt.Sprintf("agent not found for notification: %s", agentName)))
		return
	}

	// Convert the agent card to JSON
	cardJSON, err := json.MarshalIndent(agentCard, "", "  ")
	if err != nil {
		errnie.New(errnie.WithError(err))
		return
	}

	// Create a resource content with the agent card JSON
	content := ResourceContent{
		URI:      uri,
		MimeType: "application/json",
		Text:     string(cardJSON),
	}

	// Notify subscribers
	m.subManager.Notify(uri, content)

	errnie.Debug(fmt.Sprintf("Notified subscribers of agent update: %s", agentName))
}



---
File: /pkg/resources/handler.go
---

package resources

import (
	"context"

	"github.com/mark3labs/mcp-go/mcp"
)

// MCPHandler handles MCP resource requests
type MCPHandler struct {
	manager ResourceManager
}

// NewMCPHandler creates a new MCPHandler instance
func NewMCPHandler(manager ResourceManager) *MCPHandler {
	return &MCPHandler{
		manager: manager,
	}
}

// HandleListResources handles the resources/list request
func (h *MCPHandler) HandleListResources(ctx context.Context, req *mcp.ListResourcesRequest) (*mcp.ListResourcesResult, error) {
	resources, templates, err := h.manager.List(ctx)
	if err != nil {
		return nil, err
	}

	// Convert resources to MCP format
	mcpResources := make([]mcp.Resource, len(resources))
	for i, r := range resources {
		mcpResources[i] = mcp.NewResource(r.URI, r.Name,
			mcp.WithResourceDescription(r.Description),
			mcp.WithMIMEType(r.MimeType),
		)
	}

	// Convert templates to MCP format
	mcpTemplates := make([]mcp.ResourceTemplate, len(templates))
	for i, t := range templates {
		mcpTemplates[i] = mcp.NewResourceTemplate(t.URITemplate, t.Name,
			mcp.WithTemplateDescription(t.Description),
			mcp.WithTemplateMIMEType(t.MimeType),
		)
	}

	// Create result with templates in meta field
	result := &mcp.ListResourcesResult{
		Resources: mcpResources,
	}

	// Add templates to the result's meta field
	if len(mcpTemplates) > 0 {
		result.Meta = map[string]any{
			"templates": mcpTemplates,
		}
	}

	return result, nil
}

// HandleReadResource handles the resources/read request
func (h *MCPHandler) HandleReadResource(ctx context.Context, req *mcp.ReadResourceRequest) (*mcp.ReadResourceResult, error) {
	contents, err := h.manager.Read(ctx, req.Params.URI)
	if err != nil {
		return nil, err
	}

	// Convert contents to MCP format
	mcpContents := make([]mcp.ResourceContents, len(contents))
	for i, c := range contents {
		if c.Text != "" {
			mcpContents[i] = &mcp.TextResourceContents{
				URI:      c.URI,
				MIMEType: c.MimeType,
				Text:     c.Text,
			}
		} else {
			mcpContents[i] = &mcp.BlobResourceContents{
				URI:      c.URI,
				MIMEType: c.MimeType,
				Blob:     c.Blob,
			}
		}
	}

	return &mcp.ReadResourceResult{
		Contents: mcpContents,
	}, nil
}



---
File: /pkg/resources/manager.go
---

package resources

import (
	"context"
	"fmt"
	"regexp"
	"strings"
	"sync"
)

// DefaultManager is a basic implementation of ResourceManager
type DefaultManager struct {
	resources  []Resource
	templates  []ResourceTemplate
	subManager *SubscriptionManager
	mu         sync.RWMutex
	// Add a map to store active subscriptions
	activeSubscriptions map[string][]*Subscription
}

// NewDefaultManager creates a new DefaultManager instance
func NewDefaultManager() *DefaultManager {
	m := &DefaultManager{
		resources:           make([]Resource, 0),
		templates:           make([]ResourceTemplate, 0),
		subManager:          NewSubscriptionManager(),
		activeSubscriptions: make(map[string][]*Subscription),
	}

	// Add some test resources
	m.AddResource(Resource{
		URI:         "file:///test/example.txt",
		Name:        "Example Text File",
		Description: "A sample text file for testing",
		MimeType:    "text/plain",
		Type:        TextResource,
	})

	m.AddResource(Resource{
		URI:         "file:///test/image.png",
		Name:        "Example Image",
		Description: "A sample image file for testing",
		MimeType:    "image/png",
		Type:        BinaryResource,
	})

	// Add test templates
	m.AddTemplate(ResourceTemplate{
		URITemplate: "file:///test/{category}/{name}",
		Name:        "Dynamic File Template",
		Description: "A template for accessing files by category and name",
		MimeType:    "application/octet-stream",
		Type:        BinaryResource,
		Variables: []TemplateVariable{
			{
				Name:        "category",
				Description: "The category of the file",
				Required:    true,
			},
			{
				Name:        "name",
				Description: "The name of the file",
				Required:    true,
			},
		},
	})

	m.AddTemplate(ResourceTemplate{
		URITemplate: "file:///docs/{version}/{page}",
		Name:        "Documentation Template",
		Description: "A template for accessing documentation pages",
		MimeType:    "text/html",
		Type:        TextResource,
		Variables: []TemplateVariable{
			{
				Name:        "version",
				Description: "The documentation version",
				Required:    true,
			},
			{
				Name:        "page",
				Description: "The documentation page",
				Required:    true,
			},
		},
	})

	m.AddTemplate(ResourceTemplate{
		URITemplate: "file:///api/{version}/{endpoint}",
		Name:        "API Endpoint Template",
		Description: "A template for accessing API endpoints",
		MimeType:    "application/json",
		Type:        TextResource,
		Variables: []TemplateVariable{
			{
				Name:        "version",
				Description: "The API version",
				Required:    true,
			},
			{
				Name:        "endpoint",
				Description: "The API endpoint",
				Required:    true,
			},
		},
	})

	return m
}

// List returns all available resources and templates
func (m *DefaultManager) List(ctx context.Context) ([]Resource, []ResourceTemplate, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	resources := make([]Resource, len(m.resources))
	copy(resources, m.resources)

	templates := make([]ResourceTemplate, len(m.templates))
	copy(templates, m.templates)

	return resources, templates, nil
}

// Read reads the content of a resource
func (m *DefaultManager) Read(ctx context.Context, uri string) ([]ResourceContent, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	// First, check if the URI matches any templates
	matchedTemplate, templateVars := m.findMatchingTemplate(uri)

	// If a template was matched, create a dynamic resource
	if matchedTemplate != nil {
		return m.generateTemplateContent(uri, matchedTemplate, templateVars), nil
	}

	// If no template matched, look for a static resource
	resource := m.findResourceByURI(uri)
	if resource == nil {
		return nil, fmt.Errorf("resource not found: %s", uri)
	}

	// For now, return a placeholder content based on the resource type
	content := ResourceContent{
		URI:      uri,
		MimeType: resource.MimeType,
	}

	if resource.Type == TextResource {
		content.Text = fmt.Sprintf("Content of resource: %s", resource.Name)
	} else {
		// For binary resources, return a small base64-encoded placeholder
		content.Blob = "SGVsbG8gV29ybGQ=" // "Hello World" in base64
	}

	return []ResourceContent{content}, nil
}

// findMatchingTemplate finds a template that matches the given URI
func (m *DefaultManager) findMatchingTemplate(uri string) (*ResourceTemplate, map[string]string) {
	for _, t := range m.templates {
		// Try to match the URI against the template
		vars, err := matchTemplate(t.URITemplate, uri)
		if err == nil {
			return &t, vars
		}
	}
	return nil, nil
}

// findResourceByURI finds a resource by its URI
func (m *DefaultManager) findResourceByURI(uri string) *Resource {
	for _, r := range m.resources {
		if r.URI == uri {
			return &r
		}
	}
	return nil
}

// generateTemplateContent generates content for a template
func (m *DefaultManager) generateTemplateContent(uri string, template *ResourceTemplate, vars map[string]string) []ResourceContent {
	content := ResourceContent{
		URI:      uri,
		MimeType: template.MimeType,
	}

	if template.Type == TextResource {
		// For text resources, include the template variables in the content
		varInfo := "Template Variables:\n"
		for name, value := range vars {
			varInfo += fmt.Sprintf("- %s: %s\n", name, value)
		}
		content.Text = varInfo
	} else {
		// For binary resources, return a placeholder
		content.Blob = "SGVsbG8gV29ybGQ=" // "Hello World" in base64
	}

	return []ResourceContent{content}
}

// matchTemplate tries to match a URI against a template and extract variables
func matchTemplate(template, uri string) (map[string]string, error) {
	// Extract variables from the template
	variables := ParseTemplateVariables(template)
	if len(variables) == 0 {
		return nil, fmt.Errorf("template has no variables")
	}

	// Convert template to a regex pattern
	pattern := template
	for _, v := range variables {
		pattern = strings.Replace(pattern, "{"+v.Name+"}", "([^/]+)", 1)
	}
	pattern = "^" + pattern + "$"

	// Create a regex to match the URI
	re, err := regexp.Compile(pattern)
	if err != nil {
		return nil, fmt.Errorf("invalid template pattern: %w", err)
	}

	// Match the URI against the pattern
	matches := re.FindStringSubmatch(uri)
	if matches == nil {
		return nil, fmt.Errorf("URI does not match template")
	}

	// Extract variable values
	result := make(map[string]string)
	for i, v := range variables {
		if i+1 < len(matches) {
			result[v.Name] = matches[i+1]
		}
	}

	return result, nil
}

// Subscribe subscribes to resource updates
func (m *DefaultManager) Subscribe(ctx context.Context, uri string) error {
	sub, err := m.subManager.Subscribe(ctx, uri)
	if err != nil {
		return err
	}

	// Store the subscription
	m.mu.Lock()
	m.activeSubscriptions[uri] = append(m.activeSubscriptions[uri], sub)
	m.mu.Unlock()

	return nil
}

// Unsubscribe unsubscribes from resource updates
func (m *DefaultManager) Unsubscribe(ctx context.Context, uri string) error {
	subs := m.subManager.GetSubscriptions(uri)
	for _, sub := range subs {
		m.subManager.Unsubscribe(uri, sub)
	}
	return nil
}

// NotifySubscribers notifies all subscribers of a resource update
func (m *DefaultManager) NotifySubscribers(uri string, content ResourceContent) {
	m.subManager.Notify(uri, content)
}

// Close closes all subscriptions
func (m *DefaultManager) Close() {
	m.subManager.Close()
}

// AddResource adds a new resource to the manager
func (m *DefaultManager) AddResource(resource Resource) {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.resources = append(m.resources, resource)
}

// AddTemplate adds a new resource template to the manager
func (m *DefaultManager) AddTemplate(template ResourceTemplate) {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.templates = append(m.templates, template)
}



---
File: /pkg/resources/resource.go
---

package resources

import (
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"mime"
	"path/filepath"
	"strings"
)

// ResourceType represents the type of resource content
type ResourceType string

const (
	// TextResource represents a text-based resource
	TextResource ResourceType = "text"
	// BinaryResource represents a binary resource
	BinaryResource ResourceType = "binary"
)

// Resource represents a single resource in the MCP system
type Resource struct {
	URI         string       `json:"uri"`
	Name        string       `json:"name"`
	Description string       `json:"description,omitempty"`
	MimeType    string       `json:"mimeType,omitempty"`
	Type        ResourceType `json:"type"`
}

// ResourceTemplate represents a URI template for dynamic resources
type ResourceTemplate struct {
	URITemplate string             `json:"uriTemplate"`
	Name        string             `json:"name"`
	Description string             `json:"description,omitempty"`
	MimeType    string             `json:"mimeType,omitempty"`
	Type        ResourceType       `json:"type"`
	Variables   []TemplateVariable `json:"variables,omitempty"`
}

// ResourceContent represents the content of a resource
type ResourceContent struct {
	URI      string `json:"uri"`
	MimeType string `json:"mimeType,omitempty"`
	Text     string `json:"text,omitempty"`
	Blob     string `json:"blob,omitempty"` // base64 encoded
}

// ResourceManager handles resource operations
type ResourceManager interface {
	// List returns all available resources
	List(ctx context.Context) ([]Resource, []ResourceTemplate, error)

	// Read reads the content of a resource
	Read(ctx context.Context, uri string) ([]ResourceContent, error)

	// Subscribe subscribes to resource updates
	Subscribe(ctx context.Context, uri string) error

	// Unsubscribe unsubscribes from resource updates
	Unsubscribe(ctx context.Context, uri string) error
}

// NewResource creates a new Resource instance
func NewResource(uri, name string, opts ...ResourceOption) *Resource {
	r := &Resource{
		URI:  uri,
		Name: name,
	}

	// Set default MIME type based on file extension
	if ext := filepath.Ext(uri); ext != "" {
		if mimeType := mime.TypeByExtension(ext); mimeType != "" {
			r.MimeType = mimeType
		}
	}

	// Determine resource type based on MIME type
	if strings.HasPrefix(r.MimeType, "text/") || r.MimeType == "" {
		r.Type = TextResource
	} else {
		r.Type = BinaryResource
	}

	// Apply options
	for _, opt := range opts {
		opt(r)
	}

	return r
}

// ResourceOption is a function that modifies a Resource
type ResourceOption func(*Resource)

// WithDescription sets the resource description
func WithDescription(description string) ResourceOption {
	return func(r *Resource) {
		r.Description = description
	}
}

// WithMimeType sets the resource MIME type
func WithMimeType(mimeType string) ResourceOption {
	return func(r *Resource) {
		r.MimeType = mimeType
		r.Type = BinaryResource
	}
}

// NewResourceContent creates a new ResourceContent instance
func NewResourceContent(uri string, content io.Reader, mimeType string) (*ResourceContent, error) {
	rc := &ResourceContent{
		URI:      uri,
		MimeType: mimeType,
	}

	// Read content
	data, err := io.ReadAll(content)
	if err != nil {
		return nil, fmt.Errorf("failed to read content: %w", err)
	}

	// Determine if content is text or binary
	if strings.HasPrefix(mimeType, "text/") || mimeType == "" {
		rc.Text = string(data)
	} else {
		rc.Blob = base64.StdEncoding.EncodeToString(data)
	}

	return rc, nil
}

// NewResourceTemplate creates a new ResourceTemplate instance
func NewResourceTemplate(uriTemplate, name string, opts ...ResourceTemplateOption) *ResourceTemplate {
	t := &ResourceTemplate{
		URITemplate: uriTemplate,
		Name:        name,
	}

	// Set default MIME type
	t.MimeType = "application/octet-stream"
	t.Type = BinaryResource

	// Parse variables from the template
	t.Variables = ParseTemplateVariables(uriTemplate)

	// Apply options
	for _, opt := range opts {
		opt(t)
	}

	return t
}

// ResourceTemplateOption is a function that modifies a ResourceTemplate
type ResourceTemplateOption func(*ResourceTemplate)

// WithTemplateDescription sets the template description
func WithTemplateDescription(description string) ResourceTemplateOption {
	return func(t *ResourceTemplate) {
		t.Description = description
	}
}

// WithTemplateMimeType sets the template MIME type
func WithTemplateMimeType(mimeType string) ResourceTemplateOption {
	return func(t *ResourceTemplate) {
		t.MimeType = mimeType
		if strings.HasPrefix(mimeType, "text/") {
			t.Type = TextResource
		} else {
			t.Type = BinaryResource
		}
	}
}

// WithTemplateVariable adds a variable to the template
func WithTemplateVariable(name, description string, required bool) ResourceTemplateOption {
	return func(t *ResourceTemplate) {
		// Check if the variable already exists
		for i, v := range t.Variables {
			if v.Name == name {
				t.Variables[i].Description = description
				t.Variables[i].Required = required
				return
			}
		}

		// Add the variable if it doesn't exist
		t.Variables = append(t.Variables, TemplateVariable{
			Name:        name,
			Description: description,
			Required:    required,
		})
	}
}



---
File: /pkg/resources/subscription.go
---

package resources

import (
	"context"
	"sync"
	"time"
)

// Subscription represents a subscription to a resource
type Subscription struct {
	URI       string
	Channel   chan ResourceContent
	CreatedAt time.Time
	Context   context.Context
	Cancel    context.CancelFunc
}

// SubscriptionManager handles resource subscriptions
type SubscriptionManager struct {
	subscriptions map[string][]*Subscription
	mu            sync.RWMutex
}

// NewSubscriptionManager creates a new SubscriptionManager
func NewSubscriptionManager() *SubscriptionManager {
	return &SubscriptionManager{
		subscriptions: make(map[string][]*Subscription),
	}
}

// Subscribe subscribes to a resource
func (m *SubscriptionManager) Subscribe(ctx context.Context, uri string) (*Subscription, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Create a new subscription
	subCtx, cancel := context.WithCancel(ctx)
	sub := &Subscription{
		URI:       uri,
		Channel:   make(chan ResourceContent, 10),
		CreatedAt: time.Now(),
		Context:   subCtx,
		Cancel:    cancel,
	}

	// Add the subscription to the manager
	m.subscriptions[uri] = append(m.subscriptions[uri], sub)

	// Start a goroutine to clean up the subscription when the context is done
	go func() {
		<-subCtx.Done()
		m.Unsubscribe(uri, sub)
	}()

	return sub, nil
}

// Unsubscribe unsubscribes from a resource
func (m *SubscriptionManager) Unsubscribe(uri string, sub *Subscription) {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Find and remove the subscription
	if subs, ok := m.subscriptions[uri]; ok {
		for i, s := range subs {
			if s == sub {
				// Close the channel
				close(s.Channel)
				// Remove the subscription
				m.subscriptions[uri] = append(subs[:i], subs[i+1:]...)
				// If no more subscriptions for this URI, remove the URI entry
				if len(m.subscriptions[uri]) == 0 {
					delete(m.subscriptions, uri)
				}
				break
			}
		}
	}
}

// Notify notifies all subscribers of a resource update
func (m *SubscriptionManager) Notify(uri string, content ResourceContent) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	if subs, ok := m.subscriptions[uri]; ok {
		for _, sub := range subs {
			select {
			case sub.Channel <- content:
				// Content sent successfully
			default:
				// Channel is full, skip this notification
			}
		}
	}
}

// GetSubscriptions returns all subscriptions for a resource
func (m *SubscriptionManager) GetSubscriptions(uri string) []*Subscription {
	m.mu.RLock()
	defer m.mu.RUnlock()

	if subs, ok := m.subscriptions[uri]; ok {
		return subs
	}
	return nil
}

// GetSubscriptionCount returns the number of subscriptions for a resource
func (m *SubscriptionManager) GetSubscriptionCount(uri string) int {
	m.mu.RLock()
	defer m.mu.RUnlock()

	if subs, ok := m.subscriptions[uri]; ok {
		return len(subs)
	}
	return 0
}

// Close closes all subscriptions
func (m *SubscriptionManager) Close() {
	m.mu.Lock()
	defer m.mu.Unlock()

	for uri, subs := range m.subscriptions {
		for _, sub := range subs {
			sub.Cancel()
			close(sub.Channel)
		}
		delete(m.subscriptions, uri)
	}
}



---
File: /pkg/resources/template.go
---

package resources

import (
	"fmt"
	"net/url"
	"strings"
)

// TemplateVariable represents a variable in a URI template
type TemplateVariable struct {
	Name        string
	Description string
	Required    bool
}

// ParseTemplateVariables extracts variables from a URI template
func ParseTemplateVariables(template string) []TemplateVariable {
	variables := []TemplateVariable{}

	// Find all variables in the template (e.g., {category}, {name})
	parts := strings.Split(template, "{")
	for i := 1; i < len(parts); i++ {
		part := parts[i]
		endIndex := strings.Index(part, "}")
		if endIndex == -1 {
			continue
		}

		varName := part[:endIndex]
		variables = append(variables, TemplateVariable{
			Name:     varName,
			Required: true, // All variables are required by default
		})
	}

	return variables
}

// ExpandTemplate expands a URI template with provided variables
func ExpandTemplate(template string, variables map[string]string) (string, error) {
	result := template

	// Extract variables from the template
	templateVars := ParseTemplateVariables(template)

	// Check if all required variables are provided
	for _, v := range templateVars {
		if v.Required {
			if _, ok := variables[v.Name]; !ok {
				return "", fmt.Errorf("missing required variable: %s", v.Name)
			}
		}
	}

	// Replace variables in the template
	for varName, varValue := range variables {
		placeholder := "{" + varName + "}"
		result = strings.ReplaceAll(result, placeholder, varValue)
	}

	// Validate the expanded URI
	if _, err := url.Parse(result); err != nil {
		return "", fmt.Errorf("invalid URI after expansion: %w", err)
	}

	return result, nil
}

// ValidateTemplate validates a URI template
func ValidateTemplate(template string) error {
	// Check if the template contains at least one variable
	if !strings.Contains(template, "{") || !strings.Contains(template, "}") {
		return fmt.Errorf("template must contain at least one variable: %s", template)
	}

	// Check if all variables are properly closed
	openCount := strings.Count(template, "{")
	closeCount := strings.Count(template, "}")
	if openCount != closeCount {
		return fmt.Errorf("mismatched braces in template: %s", template)
	}

	// Try to parse the template to ensure it's a valid URI
	// Replace variables with placeholder values for validation
	testTemplate := template
	for i := 0; i < openCount; i++ {
		testTemplate = strings.Replace(testTemplate, "{", "test", 1)
		testTemplate = strings.Replace(testTemplate, "}", "", 1)
	}

	if _, err := url.Parse(testTemplate); err != nil {
		return fmt.Errorf("template is not a valid URI: %w", err)
	}

	return nil
}



---
File: /pkg/roots/handler.go
---

package roots

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/theapemachine/caramba/pkg/errnie"
)

// MCPHandler handles MCP requests for roots
type MCPHandler struct {
	manager RootsManager
}

// NewMCPHandler creates a new MCPHandler
func NewMCPHandler(manager RootsManager) *MCPHandler {
	return &MCPHandler{
		manager: manager,
	}
}

// HandleListRoots handles the roots/list request
func (h *MCPHandler) HandleListRoots(ctx context.Context, params json.RawMessage) (*mcp.ListRootsResult, error) {
	roots, err := h.manager.List(ctx)
	if err != nil {
		return nil, errnie.New(errnie.WithError(
			&ListRootsError{},
		))
	}

	// Convert roots to MCP format
	mcpRoots := make([]mcp.Root, 0, len(roots))
	for _, root := range roots {
		mcpRoot := mcp.Root{
			URI:  root.URI,
			Name: root.Name,
		}
		mcpRoots = append(mcpRoots, mcpRoot)
	}

	return &mcp.ListRootsResult{
		Roots: mcpRoots,
	}, nil
}

// HandleGetRoot handles the roots/get request
func (h *MCPHandler) HandleGetRoot(ctx context.Context, params json.RawMessage) (*mcp.Root, error) {
	// Parse request parameters
	var req struct {
		URI string `json:"uri"`
	}
	if err := json.Unmarshal(params, &req); err != nil {
		return nil, errnie.New(errnie.WithError(
			&ParseRequestError{RootURI: req.URI},
		))
	}

	// Find the root with the matching URI
	roots, err := h.manager.List(ctx)
	if err != nil {
		return nil, errnie.New(errnie.WithError(
			&ListRootsError{},
		))
	}

	for _, root := range roots {
		if root.URI == req.URI {
			// Convert to MCP format
			return &mcp.Root{
				URI:  root.URI,
				Name: root.Name,
			}, nil
		}
	}

	return nil, errnie.New(errnie.WithError(
		&RootNotFoundError{RootURI: req.URI},
	))
}

// HandleCreateRoot handles the roots/create request
func (h *MCPHandler) HandleCreateRoot(ctx context.Context, params json.RawMessage) (*mcp.Root, error) {
	// Parse request parameters
	var req struct {
		URI  string `json:"uri"`
		Name string `json:"name,omitempty"`
	}
	if err := json.Unmarshal(params, &req); err != nil {
		return nil, errnie.New(errnie.WithError(
			&ParseRequestError{RootURI: req.URI},
		))
	}

	// Create the root
	root := Root{
		URI:  req.URI,
		Name: req.Name,
	}

	createdRoot, err := h.manager.Create(ctx, root)
	if err != nil {
		return nil, errnie.New(errnie.WithError(
			&RootCreateError{RootURI: req.URI},
		))
	}

	// Convert back to MCP format
	return &mcp.Root{
		URI:  createdRoot.URI,
		Name: createdRoot.Name,
	}, nil
}

// HandleUpdateRoot handles the roots/update request
func (h *MCPHandler) HandleUpdateRoot(ctx context.Context, params json.RawMessage) (*mcp.Root, error) {
	// Parse request parameters
	var req struct {
		URI  string `json:"uri"`
		Name string `json:"name,omitempty"`
	}
	if err := json.Unmarshal(params, &req); err != nil {
		return nil, errnie.New(errnie.WithError(
			&ParseRequestError{RootURI: req.URI},
		))
	}

	// Find the root with the matching URI
	roots, err := h.manager.List(ctx)
	if err != nil {
		return nil, errnie.New(errnie.WithError(
			&ListRootsError{},
		))
	}

	var existingRoot *Root
	for _, root := range roots {
		if root.URI == req.URI {
			existingRoot = &root
			break
		}
	}

	if existingRoot == nil {
		return nil, errnie.New(errnie.WithError(
			&RootNotFoundError{RootURI: req.URI},
		))
	}

	// Update the root
	existingRoot.Name = req.Name
	updatedRoot, err := h.manager.Update(ctx, *existingRoot)
	if err != nil {
		return nil, errnie.New(errnie.WithError(
			&RootUpdateError{RootURI: req.URI},
		))
	}

	// Convert back to MCP format
	return &mcp.Root{
		URI:  updatedRoot.URI,
		Name: updatedRoot.Name,
	}, nil
}

// HandleDeleteRoot handles the roots/delete request
func (h *MCPHandler) HandleDeleteRoot(ctx context.Context, params json.RawMessage) (bool, error) {
	// Parse request parameters
	var req struct {
		URI string `json:"uri"`
	}
	if err := json.Unmarshal(params, &req); err != nil {
		return false, errnie.New(errnie.WithError(
			&ParseRequestError{RootURI: req.URI},
		))
	}

	// Find the root with the matching URI
	roots, err := h.manager.List(ctx)
	if err != nil {
		return false, errnie.New(errnie.WithError(
			&ListRootsError{},
		))
	}

	var rootID string
	for _, root := range roots {
		if root.URI == req.URI {
			rootID = root.ID
			break
		}
	}

	if rootID == "" {
		return false, fmt.Errorf("root not found: %s", req.URI)
	}

	// Delete the root
	err = h.manager.Delete(ctx, rootID)
	if err != nil {
		return false, errnie.New(errnie.WithError(
			&RootDeleteError{RootURI: req.URI},
		))
	}

	return true, nil
}

// HandleSubscribeToRoots handles the roots/subscribe request
func (h *MCPHandler) HandleSubscribeToRoots(ctx context.Context, params json.RawMessage) (string, error) {
	// Subscribe to root changes
	ch, err := h.manager.Subscribe(ctx)
	if err != nil {
		return "", errnie.New(errnie.WithError(
			&RootSubscribeError{},
		))
	}

	// Generate a subscription ID
	subscriptionID := fmt.Sprintf("roots-%d", len(ch))

	// Start a goroutine to handle notifications
	go func() {
		for change := range ch {
			// TODO: Send notification to client
			// This would typically involve sending an SSE event or WebSocket message
			_ = change
		}
	}()

	return subscriptionID, nil
}

// HandleUnsubscribeFromRoots handles the roots/unsubscribe request
func (h *MCPHandler) HandleUnsubscribeFromRoots(ctx context.Context, params json.RawMessage) (bool, error) {
	// Parse request parameters
	var req struct {
		SubscriptionID string `json:"subscriptionId"`
	}
	if err := json.Unmarshal(params, &req); err != nil {
		return false, errnie.New(errnie.WithError(
			&ParseRequestError{SubscriptionID: req.SubscriptionID},
		))
	}

	// Unsubscribe from root changes
	err := h.manager.Unsubscribe(ctx, req.SubscriptionID)
	if err != nil {
		return false, errnie.New(errnie.WithError(
			&RootUnsubscribeError{SubscriptionID: req.SubscriptionID},
		))
	}

	return true, nil
}

type RootNotFoundError struct {
	RootURI string
}

func (e *RootNotFoundError) Error() string {
	return fmt.Sprintf("root not found: %s", e.RootURI)
}

func (e *RootNotFoundError) Is(target error) bool {
	return target == e
}

type RootAlreadyExistsError struct {
	RootURI string
}

func (e *RootAlreadyExistsError) Error() string {
	return fmt.Sprintf("root already exists: %s", e.RootURI)
}

func (e *RootAlreadyExistsError) Is(target error) bool {
	return target == e
}

type RootUpdateError struct {
	RootURI string
}

func (e *RootUpdateError) Error() string {
	return fmt.Sprintf("failed to update root: %s", e.RootURI)
}

func (e *RootUpdateError) Is(target error) bool {
	return target == e
}

type RootCreateError struct {
	RootURI string
}

func (e *RootCreateError) Error() string {
	return fmt.Sprintf("failed to create root: %s", e.RootURI)
}

func (e *RootCreateError) Is(target error) bool {
	return target == e
}

type RootDeleteError struct {
	RootURI string
}

func (e *RootDeleteError) Error() string {
	return fmt.Sprintf("failed to delete root: %s", e.RootURI)
}

func (e *RootDeleteError) Is(target error) bool {
	return target == e
}

type RootSubscribeError struct {
	RootURI string
}

func (e *RootSubscribeError) Error() string {
	return fmt.Sprintf("failed to subscribe to root: %s", e.RootURI)
}

func (e *RootSubscribeError) Is(target error) bool {
	return target == e
}

type RootUnsubscribeError struct {
	SubscriptionID string
}

func (e *RootUnsubscribeError) Error() string {
	return fmt.Sprintf("failed to unsubscribe from root: %s", e.SubscriptionID)
}

func (e *RootUnsubscribeError) Is(target error) bool {
	return target == e
}

type ParseRequestError struct {
	RootURI        string
	SubscriptionID string
}

func (e *ParseRequestError) Error() string {
	return fmt.Sprintf("failed to parse request: %s", e.RootURI)
}

func (e *ParseRequestError) Is(target error) bool {
	return target == e
}

type ListRootsError struct {
	RootURI string
}

func (e *ListRootsError) Error() string {
	return fmt.Sprintf("failed to list roots: %s", e.RootURI)
}

func (e *ListRootsError) Is(target error) bool {
	return target == e
}



---
File: /pkg/roots/manager.go
---

package roots

import (
	"context"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/theapemachine/caramba/pkg/errnie"
)

// DefaultManager is the default implementation of RootsManager
type DefaultManager struct {
	roots       map[string]*Root
	subscribers map[string]chan *RootChange
	mu          sync.RWMutex
}

// NewDefaultManager creates a new DefaultManager instance
func NewDefaultManager() *DefaultManager {
	return &DefaultManager{
		roots:       make(map[string]*Root),
		subscribers: make(map[string]chan *RootChange),
	}
}

// List returns all available roots
func (m *DefaultManager) List(ctx context.Context) ([]Root, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	roots := make([]Root, 0, len(m.roots))
	for _, root := range m.roots {
		roots = append(roots, *root)
	}

	return roots, nil
}

// Get retrieves a root by ID
func (m *DefaultManager) Get(ctx context.Context, id string) (*Root, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	root, ok := m.roots[id]
	if !ok {
		return nil, errnie.New(errnie.WithError(
			&RootNotFoundError{RootURI: id},
		))
	}

	return root, nil
}

// Create creates a new root
func (m *DefaultManager) Create(ctx context.Context, root Root) (*Root, error) {
	// Generate a new ID if not provided
	if root.ID == "" {
		root.ID = uuid.New().String()
	}

	// Set timestamps
	now := time.Now()
	root.CreatedAt = now
	root.UpdatedAt = now

	m.mu.Lock()
	defer m.mu.Unlock()

	// Check if root with same URI already exists
	for _, existing := range m.roots {
		if existing.URI == root.URI {
			return nil, errnie.New(errnie.WithError(
				&RootAlreadyExistsError{RootURI: root.URI},
			))
		}
	}

	// Store the root
	m.roots[root.ID] = &root

	// Notify subscribers
	change := &RootChange{
		ID:        uuid.New().String(),
		RootID:    root.ID,
		Type:      RootAdded,
		Timestamp: now,
	}
	m.notifySubscribers(change)

	return &root, nil
}

// Update updates an existing root
func (m *DefaultManager) Update(ctx context.Context, root Root) (*Root, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Check if the root exists
	existingRoot, ok := m.roots[root.ID]
	if !ok {
		return nil, errnie.New(errnie.WithError(
			&RootNotFoundError{RootURI: root.ID},
		))
	}

	// Check if URI is being changed and if it conflicts with another root
	if root.URI != existingRoot.URI {
		for _, other := range m.roots {
			if other.ID != root.ID && other.URI == root.URI {
				return nil, errnie.New(errnie.WithError(
					&RootAlreadyExistsError{RootURI: root.URI},
				))
			}
		}
	}

	// Update the root
	root.CreatedAt = existingRoot.CreatedAt
	root.UpdatedAt = time.Now()
	m.roots[root.ID] = &root

	// Notify subscribers
	change := &RootChange{
		ID:        uuid.New().String(),
		RootID:    root.ID,
		Type:      RootUpdated,
		Timestamp: root.UpdatedAt,
	}
	m.notifySubscribers(change)

	return &root, nil
}

// Delete deletes a root
func (m *DefaultManager) Delete(ctx context.Context, id string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Check if the root exists
	if _, ok := m.roots[id]; !ok {
		return errnie.New(errnie.WithError(
			&RootNotFoundError{RootURI: id},
		))
	}

	// Delete the root
	delete(m.roots, id)

	// Notify subscribers
	change := &RootChange{
		ID:        uuid.New().String(),
		RootID:    id,
		Type:      RootRemoved,
		Timestamp: time.Now(),
	}
	m.notifySubscribers(change)

	return nil
}

// Subscribe subscribes to root changes
func (m *DefaultManager) Subscribe(ctx context.Context) (<-chan *RootChange, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Create a new subscriber channel
	subID := uuid.New().String()
	ch := make(chan *RootChange, 10)
	m.subscribers[subID] = ch

	// Start a goroutine to clean up the subscription when the context is done
	go func() {
		<-ctx.Done()
		m.Unsubscribe(ctx, subID)
	}()

	return ch, nil
}

// Unsubscribe unsubscribes from root changes
func (m *DefaultManager) Unsubscribe(ctx context.Context, id string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	ch, ok := m.subscribers[id]
	if !ok {
		return errnie.New(errnie.WithError(
			&RootUnsubscribeError{SubscriptionID: id},
		))
	}

	// Close the channel and remove the subscriber
	close(ch)
	delete(m.subscribers, id)

	return nil
}

// notifySubscribers notifies all subscribers of a root change
func (m *DefaultManager) notifySubscribers(change *RootChange) {
	for _, ch := range m.subscribers {
		select {
		case ch <- change:
			// Message sent successfully
		default:
			// Channel is full, skip this notification
		}
	}
}



---
File: /pkg/roots/roots.go
---

package roots

import (
	"context"
	"time"
)

// Root represents a root URI in the system
type Root struct {
	ID          string    `json:"id"`
	URI         string    `json:"uri"`
	Name        string    `json:"name"`
	Description string    `json:"description,omitempty"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
	Metadata    any       `json:"metadata,omitempty"`
}

// RootChange represents a change to a root
type RootChange struct {
	ID        string     `json:"id"`
	RootID    string     `json:"rootId"`
	Type      ChangeType `json:"type"`
	Timestamp time.Time  `json:"timestamp"`
	Metadata  any        `json:"metadata,omitempty"`
}

// ChangeType represents the type of change to a root
type ChangeType string

const (
	// RootAdded indicates a root was added
	RootAdded ChangeType = "added"
	// RootRemoved indicates a root was removed
	RootRemoved ChangeType = "removed"
	// RootUpdated indicates a root was updated
	RootUpdated ChangeType = "updated"
)

// RootsManager defines the interface for managing roots
type RootsManager interface {
	// List returns all available roots
	List(ctx context.Context) ([]Root, error)

	// Get retrieves a root by ID
	Get(ctx context.Context, id string) (*Root, error)

	// Create creates a new root
	Create(ctx context.Context, root Root) (*Root, error)

	// Update updates an existing root
	Update(ctx context.Context, root Root) (*Root, error)

	// Delete deletes a root
	Delete(ctx context.Context, id string) error

	// Subscribe subscribes to root changes
	Subscribe(ctx context.Context) (<-chan *RootChange, error)

	// Unsubscribe unsubscribes from root changes
	Unsubscribe(ctx context.Context, id string) error
}



---
File: /pkg/sampling/handler.go
---

package sampling

import (
	"context"

	"github.com/mark3labs/mcp-go/mcp"
)

// MCPHandler handles MCP requests for sampling operations
type MCPHandler struct {
	manager SamplingManager
}

// NewMCPHandler creates a new MCPHandler
func NewMCPHandler(manager SamplingManager) *MCPHandler {
	return &MCPHandler{
		manager: manager,
	}
}

// HandleCreateMessage handles the sampling/createMessage request
func (h *MCPHandler) HandleCreateMessage(ctx context.Context, req *mcp.CreateMessageRequest) (*mcp.CreateMessageResult, error) {
	// Convert MCP preferences to our format
	prefs := ModelPreferences{
		Temperature: req.Params.Temperature,
		MaxTokens:   req.Params.MaxTokens,
		Stop:        req.Params.StopSequences,
	}

	// Convert MCP messages to our format
	messages := make([]Message, len(req.Params.Messages))
	for i, msg := range req.Params.Messages {
		content := ""
		if textContent, ok := msg.Content.(*mcp.TextContent); ok {
			content = textContent.Text
		}
		messages[i] = Message{
			Role:    string(msg.Role),
			Content: content,
		}
	}

	// Create sampling options
	opts := SamplingOptions{
		ModelPreferences: prefs,
		Context: &Context{
			Messages: messages,
		},
		Stream: false,
	}

	// Create the message
	result, err := h.manager.CreateMessage(ctx, req.Params.SystemPrompt, opts)
	if err != nil {
		return nil, err
	}

	// Convert our result to MCP format
	content := mcp.NewTextContent(result.Message.Content)
	return &mcp.CreateMessageResult{
		SamplingMessage: mcp.SamplingMessage{
			Role:    mcp.Role(result.Message.Role),
			Content: content,
		},
		Model: "default", // TODO: Get actual model name
	}, nil
}

// HandleStreamMessage handles streaming message creation
func (h *MCPHandler) HandleStreamMessage(ctx context.Context, req *mcp.CreateMessageRequest) (<-chan *mcp.CreateMessageResult, error) {
	// Convert MCP preferences to our format
	prefs := ModelPreferences{
		Temperature: req.Params.Temperature,
		MaxTokens:   req.Params.MaxTokens,
		Stop:        req.Params.StopSequences,
	}

	// Convert MCP messages to our format
	messages := make([]Message, len(req.Params.Messages))
	for i, msg := range req.Params.Messages {
		content := ""
		if textContent, ok := msg.Content.(*mcp.TextContent); ok {
			content = textContent.Text
		}
		messages[i] = Message{
			Role:    string(msg.Role),
			Content: content,
		}
	}

	// Create sampling options
	opts := SamplingOptions{
		ModelPreferences: prefs,
		Context: &Context{
			Messages: messages,
		},
		Stream: true,
	}

	// Create the streaming channel
	resultChan, err := h.manager.StreamMessage(ctx, req.Params.SystemPrompt, opts)
	if err != nil {
		return nil, err
	}

	// Create MCP result channel
	mcpResultChan := make(chan *mcp.CreateMessageResult)

	// Convert sampling results to MCP results
	go func() {
		defer close(mcpResultChan)

		for result := range resultChan {
			content := mcp.NewTextContent(result.Message.Content)
			mcpResultChan <- &mcp.CreateMessageResult{
				SamplingMessage: mcp.SamplingMessage{
					Role:    mcp.Role(result.Message.Role),
					Content: content,
				},
				Model: "default", // TODO: Get actual model name
			}
		}
	}()

	return mcpResultChan, nil
}



---
File: /pkg/sampling/manager.go
---

package sampling

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
)

// DefaultManager is the default implementation of SamplingManager
type DefaultManager struct {
	defaultPrefs ModelPreferences
	mu           sync.RWMutex
}

// NewDefaultManager creates a new DefaultManager instance
func NewDefaultManager() *DefaultManager {
	return &DefaultManager{
		defaultPrefs: ModelPreferences{
			Temperature:      0.7,
			MaxTokens:        2048,
			TopP:             1.0,
			FrequencyPenalty: 0.0,
			PresencePenalty:  0.0,
		},
	}
}

// isEmptyPreferences checks if model preferences are empty/default values
func isEmptyPreferences(prefs ModelPreferences) bool {
	return prefs.Temperature == 0 && prefs.MaxTokens == 0 && prefs.TopP == 0
}

// CreateMessage creates a new message using the provided options
func (m *DefaultManager) CreateMessage(ctx context.Context, content string, opts SamplingOptions) (*SamplingResult, error) {
	startTime := time.Now()

	// Apply default preferences if not specified
	if isEmptyPreferences(opts.ModelPreferences) {
		m.mu.RLock()
		opts.ModelPreferences = m.defaultPrefs
		m.mu.RUnlock()
	}

	// TODO: Implement actual model interaction here
	// For now, just echo back the content
	message := Message{
		ID:        uuid.New().String(),
		Role:      "assistant",
		Content:   content,
		CreatedAt: time.Now(),
	}

	// Simulate token usage
	usage := Usage{
		PromptTokens:     len(content) / 4, // Rough approximation
		CompletionTokens: len(content) / 4,
		TotalTokens:      len(content) / 2,
	}

	return &SamplingResult{
		Message:  message,
		Usage:    usage,
		Duration: time.Since(startTime).Seconds(),
	}, nil
}

// StreamMessage streams message tokens as they are generated
func (m *DefaultManager) StreamMessage(ctx context.Context, content string, opts SamplingOptions) (<-chan *SamplingResult, error) {
	resultChan := make(chan *SamplingResult)

	// Apply default preferences if not specified
	if isEmptyPreferences(opts.ModelPreferences) {
		m.mu.RLock()
		opts.ModelPreferences = m.defaultPrefs
		m.mu.RUnlock()
	}

	go func() {
		defer close(resultChan)

		startTime := time.Now()
		messageID := uuid.New().String()

		// TODO: Implement actual streaming model interaction here
		// For now, just stream back the content character by character
		for i := 0; i < len(content); i++ {
			select {
			case <-ctx.Done():
				return
			default:
				message := Message{
					ID:        messageID,
					Role:      "assistant",
					Content:   string(content[i]),
					CreatedAt: time.Now(),
				}

				usage := Usage{
					PromptTokens:     1,
					CompletionTokens: 1,
					TotalTokens:      2,
				}

				resultChan <- &SamplingResult{
					Message:  message,
					Usage:    usage,
					Duration: time.Since(startTime).Seconds(),
				}

				time.Sleep(50 * time.Millisecond) // Simulate processing time
			}
		}
	}()

	return resultChan, nil
}

// GetModelPreferences returns the default model preferences
func (m *DefaultManager) GetModelPreferences(ctx context.Context) (*ModelPreferences, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	prefs := m.defaultPrefs
	return &prefs, nil
}

// UpdateModelPreferences updates the default model preferences
func (m *DefaultManager) UpdateModelPreferences(ctx context.Context, prefs ModelPreferences) error {
	// Validate preferences
	if prefs.Temperature < 0 || prefs.Temperature > 2 {
		return fmt.Errorf("temperature must be between 0 and 2")
	}
	if prefs.TopP < 0 || prefs.TopP > 1 {
		return fmt.Errorf("topP must be between 0 and 1")
	}
	if prefs.MaxTokens < 1 {
		return fmt.Errorf("maxTokens must be greater than 0")
	}

	m.mu.Lock()
	defer m.mu.Unlock()

	m.defaultPrefs = prefs
	return nil
}



---
File: /pkg/sampling/sampling.go
---

package sampling

import (
	"context"
	"time"
)

// ModelPreferences represents preferences for model behavior
type ModelPreferences struct {
	Temperature      float64  `json:"temperature"`
	MaxTokens        int      `json:"maxTokens"`
	TopP             float64  `json:"topP"`
	FrequencyPenalty float64  `json:"frequencyPenalty"`
	PresencePenalty  float64  `json:"presencePenalty"`
	Stop             []string `json:"stop,omitempty"`
}

// Message represents a message in a sampling conversation
type Message struct {
	ID        string    `json:"id"`
	Role      string    `json:"role"`
	Content   string    `json:"content"`
	CreatedAt time.Time `json:"createdAt"`
	Metadata  any       `json:"metadata,omitempty"`
}

// Context represents additional context for sampling
type Context struct {
	Messages []Message `json:"messages"`
	Files    []string  `json:"files,omitempty"`
	Data     any       `json:"data,omitempty"`
}

// SamplingOptions represents options for message creation
type SamplingOptions struct {
	ModelPreferences ModelPreferences `json:"modelPreferences"`
	Context          *Context         `json:"context,omitempty"`
	Stream           bool             `json:"stream"`
}

// SamplingResult represents the result of a sampling operation
type SamplingResult struct {
	Message  Message `json:"message"`
	Usage    Usage   `json:"usage"`
	Duration float64 `json:"duration"`
	Metadata any     `json:"metadata,omitempty"`
}

// Usage represents token usage information
type Usage struct {
	PromptTokens     int `json:"promptTokens"`
	CompletionTokens int `json:"completionTokens"`
	TotalTokens      int `json:"totalTokens"`
}

// SamplingManager defines the interface for sampling operations
type SamplingManager interface {
	// CreateMessage creates a new message using the provided options
	CreateMessage(ctx context.Context, content string, opts SamplingOptions) (*SamplingResult, error)

	// StreamMessage streams message tokens as they are generated
	StreamMessage(ctx context.Context, content string, opts SamplingOptions) (<-chan *SamplingResult, error)

	// GetModelPreferences returns the default model preferences
	GetModelPreferences(ctx context.Context) (*ModelPreferences, error)

	// UpdateModelPreferences updates the default model preferences
	UpdateModelPreferences(ctx context.Context, prefs ModelPreferences) error
}

